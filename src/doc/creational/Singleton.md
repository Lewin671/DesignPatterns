## 单例模式

单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。

一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。

单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。

### 模式结构
![单例模式结构](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Singleton.jpg)

### 模式分析
单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。

在单例模式的实现过程中，需要注意如下三点：

- 单例类的构造函数为私有；
- 提供一个自身的静态私有成员变量；
- 提供一个公有的静态工厂方法。

### 优缺点
优点:

- [x] 你可以保证一个类只有一个实例。
- [x] 你获得了一个指向该实例的全局访问节点。
- [x] 仅在首次请求单例对象时对其进行初始化。这样可以节约资源。

缺点:

- [ ] 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难
- [ ] 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
- [ ] 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。

### 实例
在Android中，我们经常用到Room组件来对数据库进行操作，其中Room数据库又包括Entity,Dao和Database三种实例。 而DataBase的实例就可以作为单例模式来创建，因为在整个app中，只需要一个database，这个database可以给我们返回不同的Dao，然后我们再根据Dao进行数据操作即可。

例如:
```kotlin
@Database(version = 1, entities = [User::class])
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao

    companion object {
        private var instance: AppDatabase? = null

        // 线程同步
        @Synchronized
        fun getDataBase(context: Context): AppDatabase {
            instance?.let {
                return it
            }
            return Room.databaseBuilder(
                context.applicationContext,
                AppDatabase::class.java, "app_database"
            ).build().apply {
                instance = this
            }
        }
    }
}
```
值得注意的是，这个方法使用了Room组件的`Synchronized`标签来表示这个方法是线程同步的方法。如果是我们自己写其他的单例模式，如果需要设计为线程安全，则可以使用`synchronize`关键字来同步整个类方法。